#' Potentially Informative Site Alignment
#'
#' Create multiple sequence alignment ggplot with [ggmsa()] from [Biostrings]
#' multiple sequence alignment subset to potentially informative sites.
#'
#' @param fasta_file FASTA file to read [DNAMultipleAlignment] from.
#' @param ... Forwarding arguments to [ggmsa::ggmsa()]
#' @export
#'
#' @return `ggmplot` object with multiple sequence alignment.
#'
#' @examples
#' \dontrun{
#' ml_fasta <-
#'   list.files("data-raw/sequencing/3.alignments-subset",
#'              full.names = TRUE)
#' potentially_informative_sites(fasta_file = ml_fasta[[1]])
#' }
#'
potentially_informative_sites <- function(fasta_file, ...) {

  # Cast matrix from unmasked Biostrings DNAMultipleAlignment object.
  dna_alignment <-
    Biostrings::readDNAMultipleAlignment(filepath = fasta_file)

  alignment_matrix <- as.matrix(Biostrings::unmasked(x = dna_alignment))

  # Keep columns with more than one character and transpose list to matrix.
  variant_sites <-
    purrr::map(1:ncol(alignment_matrix), function(site) {
      index <- alignment_matrix[, site]
    }) %>%
    purrr::keep(.x = ., ~ length(unique(.x)) > 1) %>%
    plyr::ldply(.data = .) %>% t(x = .)

  # Create DNAStringSet from vector of informative alignments.
  aligned_variants <-
    purrr::map_chr(1:nrow(variant_sites), function(index) {
      paste(variant_sites[index, ], collapse = "")
    }) %>% stats::setNames(rownames(variant_sites))

  aligned_variants <-
    Biostrings::DNAStringSet(
      x = aligned_variants
    )

  # Build ggplot with multiple sequence alignment of variable sites.
  aligned_msa <- ggmsa::ggmsa(msa = aligned_variants, ...)
  return(aligned_msa)
}

# msa | TeXshade ----

#' MSA *.tex* Subset Alignment Intervals
#'
#' Calculate a list of alignment intervals to subset a mutliple sequence
#' alignment object. Attempt to avoid Tex capacity issues.
#'
#' @param msa_alignment DNAMultipleAlignment object from Biostrings package.
#'
#' @return List of length-2 non-overlapping numeric vectors.
#' @export
#'
msa_intervals <- function(msa_alignment) {
  msa_length <- ncol(msa_alignment)
  interval_msa <- seq(136, msa_length, 165) # Account for Appendix header
  interval_list <- vector(mode = "list", length = length(interval_msa))
  if (msa_length > 135) {
    for (i in seq_along(interval_msa)) {
      if (i < max(length(interval_msa))) {
        interval_list[[i]] <- c(interval_msa[i], (interval_msa[i + 1] - 1))
      } else {
        interval_list[[i]] <- c(interval_msa[i], msa_length)
      }
    }
    interval_list <- c(list(c(1, 135)), interval_list)
  } else {
    interval_list[[i]] <- c(1, msa_length)
  }
  return(interval_list)
}

#' Subset \code{\link[msa]{msaPrettyPrint}} *.tex* Alignments
#'
#' From installed external data system files, read in alignment from FASTA
#' file, calculate alignment intervals, and write subset *.tex* output files.
#'
#' - Default subdirectory to write *.tex* alignments: `Appendix/alignments/`
#'
#' @param msa_fasta File name of `extdata/Alignments/` system file.
#'   FASTA alignments available as installed external data files.
#' @param msa_output Locus name to identify output *.tex* files.
#' @param alignment_dir Directory path to write *.tex* MSA subset files.
#'
#' @export
#'
msa_wrapper <- function(msa_fasta, msa_output,
                        alignment_dir = fs::path("Appendix/alignments/")) {

  # Assign DNA multiple alignment object from external package data:
  dna_align <-
    list.files(system.file("extdata/Alignments", package = "Thesis"),
               full.names = TRUE, pattern = msa_fasta) %>%
    Biostrings::readDNAMultipleAlignment(filepath = ., format = "fasta")

  # Write an MSA .tex file for each subset in the list of alignment intervals.
  interval_list <- Thesis::msa_intervals(msa_alignment = dna_align)
  purrr::iwalk(interval_list, function(interval, index) {
    tex_file <- fs::path(alignment_dir, paste0(msa_output, "_msa_", index),
                         ext = "tex")

    # Write subset .tex file based on alignment interval and list index.
    msa::msaPrettyPrint(
      x = dna_align, y = interval,
      alFile = fs::path(alignment_dir, msa_output, ext = "fasta"),
      file = tex_file, showLogo = "none",
      askForOverwrite = FALSE, showLegend = FALSE,
      furtherCode = "\\showruler{1}{top}", output = "tex")
  })

}

#' Format TexShade Environment
#'
#' Output *.tex* files generated by the R package msa (Bodenhofer et al. 2015)
#' define a TeXshade (Beitz 2000) environment for displaying multiple sequence
#' alignments. Additional formatting to alignment text size and optional
#' LaTeX landscape page orientation.
#'
#' Given an *.tex* file output by \code{\link[msa]{msaPrettyPrint}}, the
#' TEXshade environment text is subset and the contents overwritten to include
#' sequence alignment character sizing and formatting.
#'
#' @param tex_path MSA subset *.tex* file path
#' @param landscape Logical scalar to add LaTeX landscape page formatting.
#'   Used for alignment intervals after first 165 residues to accomodate
#'   chapter headings.
#'
#' @export
#'
msa_texshade <- function(tex_path, landscape = FALSE) {

  # Subset TexShade LaTeX environment from msa::msaPrettyPrint() .tex output.
  raw_tex <- readr::read_lines(file = tex_path)
  texshade_start <- grep(pattern = "\\\\begin\\{texshade\\}", x = raw_tex)
  texshade_end <- grep(pattern = "\\\\end\\{texshade\\}", x = raw_tex)
  tex_env <- raw_tex[texshade_start:texshade_end]

  # Vector of additional .tex formatting
  tex_formatting <- c("\\setsize{numbering}{tiny}",
                      "\\setsize{names}{tiny}",
                      "\\setsize{residues}{tiny}",
                      "\\setsize{consensus}{tiny}")

  # Format first page of TEXshade sequence alignment:
  if (landscape == FALSE) {
    texshade_out <- c("\\vfill", "\\centering",
                      "\\begin{rotate}{90}", "\\begin{minipage}{7in}",
                      tex_env[1], tex_formatting, tex_env[2:length(tex_env)],
                      "\\end{minipage}", "\\end{rotate}")
  }

  # Format subsequent alignment pages as landscape orientation.
  if (landscape == TRUE) {
    texshade_out <- c("\\begin{landscape}", tex_env[1],
                      "\\alignment{left}", "\\residuesperline*{165}",
                      tex_formatting, tex_env[2:length(tex_env)],
                      "\\end{landscape}")
  }

  cat(texshade_out, file = tex_path, sep = "\n")
}
