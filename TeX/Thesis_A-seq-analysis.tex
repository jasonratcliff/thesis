\chapter*{APPENDIX B}
\addcontentsline{toc}{chapter}{APPENDIX B: SEQUENCE ANALYSIS}
\begin{center}
SEQUENCE ANALYSIS
\end{center}

\section*{Sequence Analysis Pipeline}

\paragraph{} An overview of the steps taken to process sequence data prior to phylogenetic inference follows:

% Define a new environment and adjust spacing for enumerated and itemized lists.
\newenvironment{seqlist}
{\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt} }
{\end{enumerate} } 

\begin{seqlist}
\item{\textbf{Directory Environment}}
\begin{itemize}
\item{Establish sequence analysis project directory}
\item{Deposit \textit{Fasta\_Utilities/} scripts as a project subdirectory}
\end{itemize}

\item{\textbf{FASTA File Import}}
\begin{itemize}
\item{Deposit unaligned multi-FASTA files in \textit{0.raw\_fastas/} subdirectories}
\end{itemize}

\item{\textbf{Cleaning Data}}
\begin{itemize}
\item{Run \textit{./Fasta\_Utilities/fasta\_diffs.sh}}
\begin{itemize}
\item{Script generates output files containing respective loci sequence headers}
\end{itemize}
\begin{itemize}
\item{For concatenated, multi-locus analyses:}
\begin{itemize}
\item{Manually remove excess sequences based on sequence header differences}
\item{Concatenated FASTA includes the same DNA specimens for all loci}
\end{itemize}
\end{itemize}
\item{Save trimmed multi-FASTA files in \textit{1.trimmed\_fastas\_ml} subdirectory}
\end{itemize}

\item{\textbf{Multiple Sequence Alignment}}
\begin{itemize}
\item{Utilize remote MAFFT server for individual loci alignments}
\item{Save aligned (wrapped) multi-FASTA files in \textit{2.aligned\_fastas}}
\end{itemize}

\item{\textbf{FASTA File Unwrap}}
\begin{itemize}
\item{AWK / Sed processing of aligned multi\_FASTA files}
\end{itemize}

\item{\textbf{\textit{unwrap\_fasta.sh} Loop Contsruct}}
\begin{itemize}
\item{Output unwrapped multi-FASTA files into \textit{3.unwrapped\_fastas}}
\end{itemize}

\item{\textbf{Sequence Concatenation and \textit{multi-fasta\_split.sh} Loop Construct}}
\begin{itemize}
\item{Manually concatenate multi-locus FASTA from individual loci}
\item{Output split sequences into \textit{4.loci} subdirectories}
\end{itemize}

\clearpage

\item{\textbf{FASTA File Split}}
\begin{itemize}
\item{AWK processing of multi-FASTA files to split into single sequence text files}
\end{itemize}

\item{\textbf{Source Sequences into R}}
\begin{itemize}
\item{Read individual sequences into workspace with \textit{load\_fastas.R}}
\item{Return pairwise sequence differences using \textit{seq\_comp.R}}
\end{itemize}

\end{seqlist}

\subsection*{System Information}

\paragraph{} Local analyses were run with Mac OS X version 10.11.6, Unix OS Darwin version 15.6.0, and Terminal version 2.6.1 on an x86\_64 processor.  Remote servers on the CIPRES Science Gateway (Miller et al. 2010) were utilized for alignment and phylogenetic inference.  

\subsection*{1. Directory Environment}

\paragraph{} A project directory was established for holding sequence data, program scripts, and intermediate files related to DNA sequence analysis.  The program-containing subdirectory \textit{Fasta\_Utilities/} was then moved from the parent directory into the project directory (Figure B1).  In the following code snippets, the character "\textbf{\$}" indicates the command prompt of the command line interface while text following a "\textbf{\#}" indicates commented (i.e. non-evaluated) code.  The \LaTeX package Listings (Hoffmann et al. 2015) was used to modify code syntax coloring, where functions are keywords represented by the color blue and the command prompt is colored green.

\vspace*{36pt}

\begin{lstlisting}[caption={Project directory setup.}]
# Establish project directory and setup working directory.
|<$>| mkdir Seq-Analysis
|<$>| cd Seq-Analysis
|<$>| mv ../Fasta_Utilities/ .  
\end{lstlisting}

\clearpage

\paragraph{} The \textit{Fasta\_Utilities/} directory contains executable shell (.sh) scripts and a subdirectory with scripts containing R functions (Figure B2).  Here, a bash shell was used for evaluation of sequence analysis program files. 

\vspace*{36pt}

\begin{lstlisting}[caption={Contents of \textit{Fasta\_Utilities/} subdirectory.}]
# Recursivley list shell script and R source code with file permissions.
|<$>| ls -lR Fasta_Utilities/ | awk '{print $1, $9}'
total
drwxr-xr-x R_functions
-rwxr-xr-x fasta_diffs.sh
-rwxr-xr-x multi-fasta_split.sh
-rwxr-xr-x unwrap_fasta.sh
 
Fasta_Utilities//R_functions:     # R function directory
total 
-rw-r--r-- identity_check.R
-rw-r--r-- load_fastas.R
-rw-r--r-- seq_comp.R
\end{lstlisting}

\vspace*{36pt}

\subsection*{2. FASTA File Import}

\paragraph{} A directory for the unaligned multi-FASTA files was established in the project directory (Figure B3).  The following naming convention was observed for FASTA files used as inputs for shell scripts: name of the genomic loci followed by a dash, additional filename descriptions separated by underscores, and the text extension, ".fasta" (e.g. loci-combined\_raw.fasta).  Multi-FASTA files were manually deposited in the directory \textit{0.raw\_fastas/} once established.

\clearpage

\begin{lstlisting}[caption={Unaligned sequence data deposited in \textit{0.raw\_fastas/} subdirectory.}]
# Establish directory for unaligned FASTA files.
|<$>| mkdir 0.raw_fastas

# List unaligned sequence FASTA files in initial analysis directory.
|<$>| ls 0.raw_fastas/ | more
rITS-combined_raw.fasta
rps-combined_raw.fasta
ycf1-combined_raw.fasta
\end{lstlisting}

\vspace*{36pt}

\subsection*{3. Cleaning Data}

\paragraph{} Prior to alignment and concatenation, loci with specimens missing sequence data were identified using the \textit{fasta\_diffs.sh} shell script to facilitate the comparison of FASTA file sequence headers.  Following the execution of this script, the sequence header difference files were analyzed and loci with extra specimen sequences were manually removed prior to sequence concatenation.  This script allows for three arguments denoted by the command flags [-D], [-N], and [-f] (Figure B4).  These options are parsed using the builtin utility \textbf{getopts} which evaluates a string of options - referred to as \textbf{optstring} (here, "D:N:f:"), where colons denote an expected argument for each respective option (Kerrisk 2018).  As each option is evaluated, the string option is set to the variable \textbf{\$opt} and any optional argument is set to the variable \textbf{\$OPTARG}.  This is combined with the \textbf{case...in...esac} shell flow control structure (WÃ¼nschiers 2013), where the string in variable \textbf{\$opt} is checked against patterns denoted by a closed parentheses - here, "D)", "N)", "f)", and "?)" (Lines 4, 7, 10, \& 13; Figure B4).  When a pattern is matched by the value of \textbf{\$opt}, the action(s) following the parentheses are executed.  If a command option is not contained in the string of options \textbf{optstring}, the value of that option is set to "?" (Kerrisk 2018).

\clearpage

\begin{lstlisting}[numbers=left, showstringspaces=false, caption={Use of GETOPTS to parse script options.}]
# Use builtin function GETOPTS to parse shell variables.
while getopts "D:N:f:" opt ; do
  case $opt in
    D)  # Directory containing FASTA files
      directory="$OPTARG"
      ;;
    N)  # New directory to copy FASTA files for manual edits
      new_directory="$OPTARG"
      ;;
    f)  # String to append to FASTA filename
      filename="$OPTARG"
      ;;
    ?) # Warning for non-matching option flags pass as arguments
      echo "Invalid option: -$OPTARG"
      echo "Usage: fasta_diff.sh [-D] [-N] [-f]"
      ;;
  esac
done
\end{lstlisting}

\vspace*{36pt}

\paragraph{} The \textit{fasta\_diffs.sh} script takes an argument denoted by option [-D] representing a project subdirectory containing multiple individual loci multi-FASTA files (Figure B5).  The command should be executed from the main level of the project directory as follows:

\vspace*{36pt}

\begin{lstlisting}[caption={Basic usage of \textit{fasta\_diffs.sh} script.}]
|<$>| ./Fasta_Utilities/fasta_diffs.sh -D 0.raw_fastas/
\end{lstlisting}

\clearpage

\paragraph{} When the [-D] option is included, the string of the directory path is stored as the shell variable \textbf{\$directory} (Line 5, Figure B4).  Parameter substitution is used to slice the last character of the directory string as the variable \textbf{\$dir\_end} (Line 2, Figure B6), which should match the forward slash character "/" denoting a file directory.  If the directory represented by the variable \textbf{\$directory} is an existing directory and the variable \textbf{\$dir\_end} matches a forward slash, the existence of a subdirectory \textit{seq\_headers/} is checked (Lines 3 \& 5, Figure B6).  If no such directory exists, the subdirectories \textit{seq\_headers/} and \textit{seq\_diffs/} are established using the \textbf{mkdir} utility (Line 6, Figure B6).

\vspace*{36pt}

\begin{lstlisting}[numbers=left, showstringspaces=false, escapechar=\%, caption={Verify directory existence and create subdirectories.}]
# Check if input argument [-D] is a directory AND ends in character "/".
dir_end=${directory:${%\#%directory}-1}
if [ -d "$directory" ] && [ $dir_end  = "/" ] ; then
  # Create subdirectories for sequence headers and header diffs.
  if [ ! -d ${directory}seq_headers/ ] ; then  
    mkdir ${directory}seq_headers/ && mkdir ${directory}seq_diffs/
  else 
    echo  # notification that directory already exists ...
    echo "Directory" ${directory}seq_headers/ "already exists !"
  fi
# Exit program if argument [-D] is not a directory ending in "/".
else  
  echo "Exiting..." $directory "is not a directory..."; exit
fi
\end{lstlisting}

\vspace*{36pt}

\paragraph{}  To compare multi-FASTA file sequence headers, a \textbf{for loop} control flow structure is set up to iterate through all files in the directory given by option [-D] (represented by shell variable \textbf{\$directory}) matching the extension ".fasta" (Line 2, Figure B7), where the character "*" matches any string pattern (GNU Bash Manual 3.5.8.1).  In each loop iteration, the FASTA filename is stored as shell variable \textbf{\$fasta}.  The genomic loci for the respective fasta file is then sliced from \textbf{\$fasta} to remove the directory name and any text following <loci->, as previously described in the file naming convention, and stored as shell variable \textbf{\$loci} (Lines 6 \& 7, Figure B7) (GNU Bash Manual 3.5.3).

\vspace*{36pt}

\begin{lstlisting}[numbers=left, showstringspaces=false, escapeinside={(*@}{@*)}, caption={FASTA file sequence header extraction \textbf{for loop} in the \textit{fasta\_diffs.sh script.}}]
# Iterate through FASTA files in directory [-D] main level.
for fasta in ${directory}*.fasta; do
  echo $fasta  # full file path to fasta from main level
  
  # Slice the loci substring following variable substitution syntaxes.
  loci=${fasta(*@{\#\#}@*)${directory}}
  loci=${loci%-*}
  echo '  Processing loci' $loci "..."
  
  # Extract headers from the FASTA file using AWK.
  headers=${directory}seq_headers/${loci}
  awk '/^>/ {print $1}; END {print NR}' $fasta > ${headers}-seqs.txt
 
  # Print number of FASTA headers.
  awk 'END {printf("\tFASTA headers:%s\n", NR)}' ${headers}-seqs.txt

  # Sort the sequence headers and redirect the output to a new file.
  sort ${headers}-seqs.txt > ${headers}-sorted_seqs.txt
  
done

\end{lstlisting}

\clearpage

\paragraph{} After declaring shell variables \textbf{\$fasta} and \textbf{\$loci}, headers from the multi-FASTA files are analyzed using an AWK (version 20070501) statement to print the FASTA sequence header lines demarcated by ">".  The AWK programming language evaluates each line - also referred to as a record - of an input file for a specified pattern, and executes a defined action on records matching the pattern (Aho et al. 1988).  If no action is defined, the default action is to print the record where the entire record is represented by the variable "\$0".  The general syntax of an AWK statement is as follows (Figure B8):

\vspace*{36pt}

\begin{lstlisting}[caption={An example AWK statement.}]
# General AWK syntax:
|<$>| awk ' pattern  { action } '  filename
\end{lstlisting}

\vspace*{36pt}

\paragraph{} Within an AWK statement, a pattern can consist of a regular expression indicated between forward slashes "/ /" (WÃ¼nschiers 2013, p. 201-202).  The \textit{fasta\_diffs.sh} script contains an AWK statement used to identify records (i.e. multi-FASTA file lines) that begin with the character ">", which denotes a FASTA sequence header.  To match these records, the regular expression position anchor caret character "\string^" is used to indicate the start of a line (WÃ¼nschiers 2013, p.166).  In the first \textit{fasta\_diffs.sh} AWK statement, combining "\string^" with the character ">"  establishes a regular expression matching records beginning with ">" (Line 12, Figure B7).  When this pattern is matched, the respective action for that record (i.e. sequence header line) is executed.  Here, the first field (indicated by \textbf{\$1}) of the record is printed, where fields are separated by default with a space (WÃ¼nschiers 2013, p. 198).  Following evaluation of the final input file line, an AWK END statement is invoked (WÃ¼nschiers 2013, p. 207) to print the value of a predefined AWK variable \textbf{NR} returning the number of records in the input file (WÃ¼nschiers 2013, p. 212).  The input filename for the first AWK statement is indicated by the shell variable \textbf{\$fasta} (Line 12, Figure B7).  Output from this AWK statement is then redirected as standard input using the UNIX assignment operator ">" to write a new text file.  A variable \textbf{\$headers} is declared using variable expansion of \textbf{\$directory} and \textbf{\$loci} (Line 11, Figure B7) to form a filepath used to write new files in the \textit{seq\_headers/} directory with the string "-seqs.txt" appended to the filename.

\paragraph{} A second AWK statement evaluates the sequence header file written by the first (Line 15, Figure B7).  Here, an AWK END statement is invoked to print the number of records in the sequence header file to the command line interface.  This statement utilizes the command \textbf{printf} which allows for formatting the print output (Aho et al. 1988).  By default, \textbf{printf} does not append newline characters to the end of a print statement.  Instead, a string is used to dictate the output format of subsequent items (e.g. variables, strings, or numerics) where a format specifier indicates the type of item to be printed (WÃ¼nschiers 2013, p. 227).  To print the string in variable \textbf{NR}, the format specifier for strings "\%s" is combined with the special characters "\textbackslash t" and "\textbackslash n" for tab and newline characters, respectively, in addition to the string "FASTA headers:" (Line 15, Figure B7).  The newly written FASTA sequence header file is called as the AWK statement input file (Line 15, Figure B7).  This effectively prints the number of sequence headers in the FASTA file to the command line interface (Figure Appendix 9).

\vspace*{36pt}

\begin{lstlisting}[caption={Output of \textit{fasta\_diffs.sh} script.}]
|<$>| ./Fasta_Utilities/fasta_diffs.sh -D 0.raw_fastas/
0.raw_fastas/rITS-combined_raw.fasta
  Processing loci rITS ...
	FASTA headers:71
0.raw_fastas/rps-combined_raw.fasta
  Processing loci rps ...
	FASTA headers:67
0.raw_fastas/ycf1-combined_raw.fasta
  Processing loci ycf1 ...
	FASTA headers:50
\end{lstlisting}

\clearpage

\paragraph{} To faciliate FASTA sequence header comparisons, an indexed array \textbf{\$sorted\_fastas} is declared to contain the filenames of all sorted sequence header files in the respective \textit{seq\_headers/} directory (Line 2, Figure B10).  Array elements can be referred to using the contstruct \textit{\$\{name[subscript]\}} where the character "@" can be substituted for \textit{subscript} to reference all elements of the array (GNU Bash Manual 6.7).  Using the "\#" character preceding \textit{name} expands to the length of the array elements included where \textit{\$\{\#name[@]\}} returns the total number of elements in an array.  Notably, indexed arrays are zero-based such that the subscript referring to the first array element is 0.

\paragraph{} A nested loop construct (GNU Bash Manual 3.2.4.1) is established using C style shell arithmetic (GNU Bash Manual 6.5) with the first of two loops consisting of the following three expressions (Line 5, Figure B10): "i=0", \mbox{"i < (( \$\{\#sorted\_fastas[@]\} - 1 ))"}, and "i++".  The first expression is evaluated such that variable \textbf{i} is set to 0.  The second expression is then evaluated repeatedly until the expression is false.  For each iteration where the expression is true, the commands in the loop (here the second, inner loop construct; lines 8-21, Figure B10) are executed and the third expression is evaluated to increase the value of \textbf{i} by an increment of 1.  Here, the second expression is true for each iteration where \textbf{i} is less than the total number of \textbf{\$sorted\_fastas} array elements (i.e. sorted sequence header files) minus one.  Therefore, if there are three sorted sequence header files, the outer loop will be executed only twice.

\paragraph{} In the inner loop, expansion of the \textbf{seq} utility returns a sequence of integers from the value of \textbf{i} set in the outer loop to the value of two less than the total number of array elements in \textbf{\$sorted\_fastas} (Line 8, Figure B10).  A variable for the name of the first loci FASTA header file is established by slicing the preceding directory path and substring following the loci name (Lines 11 \& 12, Figure B10).  The value of \textbf{j} is then used to set the name of the comparison loci as \textbf{\$loci2} based on the array element in \textbf{\$sorted\_fastas} (Lines 13 \& 14, Figure B10).  Finally, the \textbf{diff} utility is used to compare the sequence headers in the array element FASTA header file set by subscript \textbf{i} to that set by \textbf{j}, the output of which is directed into a file named by the two loci being compared (Lines 18 \& 19, Figure B10).  Therefore in a directory with three FASTA files, the nested loop construct compares the first FASTA header file with the second and third in the first pass, then compares the second FASTA header file with the third on the second pass. 

\clearpage

\begin{lstlisting}[numbers=left, escapeinside={(*@}{@*)}, caption={Sequence header file difference comparisions.}]
# Create indexed array of sorted FASTA sequence header files.
sorted_fastas=(${directory}seq_headers/*sorted*)

# Iterate through array elements prior to the final element.
for ((i=0; i < (( ${(*@{\#}@*)sorted_fastas[@]} - 1 )); i++)); do 

  # Nested loop for pairwise sequence header comparisions.
  for j in $(seq $i $(( ${(*@{\#}@*)sorted_fastas[@]} - 2 ))); do
  
    # Slice variables from loci names for sequence header diff files.
    loci1=${sorted_fastas[i](*@{\#\#}@*)*/seq_headers/}
    loci1=${loci1%-sorted*}
    loci2=${sorted_fastas[$(( $j + 1 ))](*@{\#\#}@*)*/seq_headers/}
    loci2=${loci2%-sorted*}

    # Create file with pairwise diff calculations of sequence headers.
    # diff command flag "-b" ignores white space.
    diff -b ${sorted_fastas[i]} ${sorted_fastas[$(( $j + 1 ))]} > \
    ${directory}seq_diffs/diffs-${loci1}_${loci2}.txt
  
  done
  
done
\end{lstlisting}

\vspace*{36pt}

\paragraph{} When the optional argument [-N] is included, a variable \textbf{\$new\_directory} is declared (Line 8, Figure B4) to establish a new directory with FASTA files copied from the directory set by the [-D] argument.  If the string in \textbf{\$new\_directory} is not empty (Line 1, Figure B11), the final character is sliced as the variable \textbf{\$new\_dir\_end} (Line 3, Figure B11) and a new directory is established if \textbf{\$new\_directory} is not an existing directory and \textbf{\$new\_dir\_end} matches the character "/" (Lines 13-14, Figure B11).  FASTA files in the directory set by [-D] are then copied to the new directory (Line 18, Figure B11).  

\vspace*{36pt}

\begin{lstlisting}[numbers=left, showstringspaces=false, escapechar=\%, caption={Establish a new directory and copy FASTA files for manual edits.}]
if [ -n "$new_directory" ]; then

  new_dir_end=${new_directory:${#new_directory}-1}
  
  if [ -d "$new_directory" ]; then  # check directory existence
      echo "Directory" $new_directory "already exists !" 
  fi
  if [ "$new_dir_end"  != "/" ]; then  # check final directory character
      echo "Exiting..." $new_directory "is not a valid directory name."; 
      exit
  fi
  # Check if input argument [-N] exists AND ends in character "/".
  if [ ! -d "$new_directory" ] && [ "$new_dir_end"  = "/" ]; then 
    mkdir ${new_directory}
  fi
  
  # Copy multi-FASTA files into a second directory for manual trimming.
  cp ${directory}*fasta $new_directory
\end{lstlisting}

\vspace*{36pt}

\paragraph{} After copying files to the new directory, the option [-f] can be used to append a sequence filename string to the FASTA loci.  When variable \textbf{\$filename} is set (Line 11, Figure B4), if it is a non-empty string (Line 2, Figure B12) the last six characters of the character string in \textbf{\$filename} are sliced as variable \textbf{\$fasta\_ext} (Line 4, Figure B12).  If the value of \textbf{\$fasta\_ext} matches the string ".fasta", the file extension is removed from \textbf{\$filename} (Lines 5 \& 6, Figure B12).  Lastly, a for loop is established to rename the copied files in the new directory with the value of \textbf{\$filename} by isolating the name of the loci (Lines 10 \& 11, Figure B12) as variable \textbf{\$loci} and then using the \textbf{mv} utility for each file \textbf{\$fasta} by the variable construct \textbf{\mbox{"\$\{new\_directory\}\$\{loci\}-\$\{filename\}.fasta"}} (Line 12, Figure B12).  

\vspace*{36pt}

\begin{lstlisting}[numbers=left, escapeinside={(*@}{@*)}, caption={Optional renaming of copied FASTA files.}]
  # Optional string to append to filenames after copying to new directory.
  if [ -n "$filename" ]; then
    # Slice last six characters from filename string to verify extension.
    fasta_ext=${filename:${(*@{\#}@*)filename}-6}  
    if [ "$fasta_ext" = ".fasta" ]; then
      filename=${filename%.fasta}  # remove ".fasta" extension if present
    fi
    # Rename the copied raw files prior to manual removing extra sequences.
    for fasta in ${new_directory}*fasta; do
      loci_file=${fasta(*@{\#\#}@*)${new_directory}}
      loci=${loci_file%-*}
      mv $fasta ${new_directory}${loci}-${filename}.fasta
    done
  fi
fi
\end{lstlisting}

\clearpage

\paragraph{} Executing the \textit{fasta\_diffs.sh} script on the \textit{0.raw\_fastas/} directory creates sorted sequence header and header difference files for FASTA files contained therein.  FASTA files in \textit{0.raw\_fastas/} were copied to a new directory \textit{1.trimmed\_fastas\_ml} (indicated by [-N]) with the filename "trimmed\_ml" (indicated by [-f]) appended to the sequence loci.  Usage of the script is as follows:

\vspace*{36pt}

\begin{lstlisting}[caption={Execute the program from the main level of the project directory.}]
|<$>| ./Fasta_Utilities/fasta_diffs.sh -D 0.raw_fastas/ \
> -N 1.trimmed_fastas_ml -f trimmed_ml
0.raw_fastas/rITS-combined_raw.fasta
  Processing loci rITS ...
	FASTA headers:71                 # number of sequence headers
0.raw_fastas/rps-combined_raw.fasta
  Processing loci rps ...
	FASTA headers:67
0.raw_fastas/ycf1-combined_raw.fasta
  Processing loci ycf1 ...
	FASTA headers:50
\end{lstlisting}

\vspace*{36pt}

\paragraph{} After determining which specimens had sequence data for all three loci, extra sequences were removed manually from FASTA files in \textit{1.trimmed\_fastas\_ml} prior to alignment.  Running the \textit{fasta\_diffs.sh} script with \textit{1.trimmed\_fastas\_ml/} for option [-D] will create sequence header difference files for the trimmed FASTA files in the new directory.  Trimmed FASTA files should have an equivalent number of specimens, an attribute that can be verified using the word count utility \textbf{wc} with the option [-l] to count the number of lines in the sorted sequence header files (Line 13, Figure B14).

\clearpage

\begin{lstlisting}[numbers=left, caption={Verify equal specimen sampling between loci.}]
|<$>| ./Fasta_Utilities/fasta_diffs.sh -D 1.trimmed_fastas_ml/
1.trimmed_fastas_ml/rITS-trimmed_ml.fasta
  Processing loci rITS ...
	FASTA headers:46
1.trimmed_fastas_ml/rps-trimmed_ml.fasta
  Processing loci rps ...
	FASTA headers:46
1.trimmed_fastas_ml/ycf1-trimmed_ml.fasta
  Processing loci ycf1 ...
	FASTA headers:46
	
|<$>| wc -l 1.trimmed_fastas_ml/seq_headers/*sorted*
      46 1.trimmed_fastas_ml/seq_headers/rITS-sorted_seqs.txt
      46 1.trimmed_fastas_ml/seq_headers/rps-sorted_seqs.txt
      46 1.trimmed_fastas_ml/seq_headers/ycf1-sorted_seqs.txt
     138 total
\end{lstlisting}

\vspace*{36pt}


\paragraph{} The "EXIT" statement is used to leave the program if the record does not start with ">" (i.e. is a sequence header) and also contains a character that is not either alphabetical (upper- or lowercase) or a dash (i.e. sequence data).  This is an important step to prevent potential silent errors in program output.  

\clearpage

\begin{lstlisting}[caption={\textit{unwrap\_fasta.sh} AWK EXIT statement}]
# EXIT statement
$0 !~ /^>/ && $0 !~ /^[A-Za-z\-]+$/ {exit}
\end{lstlisting}

\vspace*{30pt}

\paragraph{} After evaluating the final record of the input file, the action within the END block is executed, printing one additional newline character.  The shell variable "\textbackslash\$1" is used to indicate a program parameter specifying which input file (e.g. ``rITS\_aligned.fastaâ) the AWK statements should evaluate.  The output of the AWK statements is then redirected using the pipe character (``|â) as the standard input for a Sed expression.

\vspace*{30pt}

\begin{lstlisting}[caption={AWK END Block and Sed Redirection}]
# END block and output redirection
END {print ``\n''}' $1 | sed /^$/d
\end{lstlisting}

\vspace*{30pt}

\paragraph{} Sed, or Streamline Editor, operates by reading lines from the standard input, consecutively saving a copy of a line in pattern space - Sedâs working memory, and executing the command within the pattern space (WÃ¼nschiers 2013).  Edited text is sent from pattern space as standard output that can be redirected with the shell assignment operator ``>â to a new file.  The \textit{unwrap\_fasta.sh} program uses a Sed edit command to remove blank lines.  The regular expression ``/\string^\$/â will match any lines containing no text, referred to as empty or null strings.  This expression is combined with ``dâ, invoking the Sed delete command.  Thus, any records containing no text and therefore only a hidden newline character are deleted from the standard input.  

\clearpage

\subsection*{6. \textit{unwrap\_fasta.sh} Loop Construct}

\paragraph{} Executing \textit{unwrap\_fasta.sh} on a multi-FASTA file containing wrapped sequences returns a file containing sequence header strings each followed by a corresponding sequence string, with each string occupying a single line.  A subdirectory was established within the project directory to store the unwrapped sequences.  A loop was then utilized to execute the script for each multi-FASTA in the \textit{2.aligned\_fastas/} subdirectory.  Program output is redirected to new files contained in the \textit{3.unwrapped\_fastas/} subdirectory named by the loci prefix.

\vspace*{30pt}

\begin{lstlisting}[caption={\textit{unwrap\_fasta.sh} Loop Contstruct}]
# Make a new directory to store unwrapped output.
|<$>| mkdir 3.unwrapped_fastas

# Execute the unwrap_fasta.sh script
# on each file in  the 2.aligned_fastas/ subdirectory.

for fasta in $(ls 2.aligned_fastas/); do
 loci=${fasta%_aligned.fasta};   # Slice the loci prefix as variable
 ./Fasta_Utilities/unwrap_fasta.sh 2.aligned_fastas/$fasta > \
 3.unwrapped_fastas/${loci}_unwrapped.fasta;
done
\end{lstlisting}

\vspace*{30pt}

\paragraph{} Script execution can be verified by checking the number of lines in the unwrapped FASTA files.  Each FASTA, having the same number of sequence headers with respective aligned sequence strings, are expected to have an equal number of lines.

\clearpage

\begin{lstlisting}[caption={Verify line count of unwrapped FASTA files}]
# Verify the number of lines with the wc utility.
$ wc -l 3.unwrapped_fastas/*
     102 3.unwrapped_fastas/multi-locus_unwrapped.fasta
     102 3.unwrapped_fastas/rITS_unwrapped.fasta
     102 3.unwrapped_fastas/rps_unwrapped.fasta
     102 3.unwrapped_fastas/ycf1_unwrapped.fasta
     408 total
\end{lstlisting}

\vspace*{30pt}

\subsection*{7. Sequence Concatenation}

\paragraph{} After unwrapping individual loci files, a concatenated file was manually assembled for downstream partitioned analysis.  It should be noted that a script to automatically concatenate sequence strings based on a list of shared sequence headers could prevent errors in manual assembly.  However, that approach was not taken for this task.  Instead, the multi-locus file \textit{multi-locus\_unwrapped.fasta} was manually assembled and deposited in the \textit{3.unwrapped\_fastas} subdirectory.  

\subsection*{8. \textit{multi-fasta\_split.sh} Loop Construct}

\paragraph{} The shell script \textit{multi-fasta\_split.sh} was written to split multi-FASTA files into individual, single line text files containing an alignment-gapped sequence string.  A loop was employed to execute this script on the unwrapped FASTA files in the \textit{3.unwrapped\_fastas/} directory.  For each FASTA file in the unwrapped FASTA directory, the name of the loci is sliced into a shell variable and used to name a new directory.  The respective FASTA file is then copied into the new directory and \textit{multi-fasta\_split.sh} is executed on the unwrapped FASTA input file.  In the last step of the loop, the input file for execution is represented by the variable construct \textbf{4.\$\{loci\}\_seqs/\$\{loci\}\_unwrapped.fasta}.

\clearpage

\begin{lstlisting}[caption={textit{multi-fasta\_split.sh} Loop Contstruct}]
for fasta in $(ls 3.unwrapped_fastas/); do
  # Slice "_unwrapped.fasta" substring
  loci=${fasta%_unwrapped.fasta};   
  mkdir 4.${loci}_seqs;     # Subdirectories named by ${loci} expansion
  
  # Copy unwrapped FASTAs into new subdirectory for splitting sequences
  cp 3.unwrapped_fastas/${loci}* 4.${loci}_seqs;
  
  # Execute the multi-fasta_split.sh script on the unwrapped FASTA
  ./Fasta_Utilities/multi-fasta_split.sh \
  4.${loci}_seqs/${loci}_unwrapped.fasta;
done
\end{lstlisting}

\vspace*{30pt}

\paragraph{} This loop establishes four new directories, each containing sequence string files split from the respective unwrapped FASTA file.

\vspace*{30pt}

\begin{lstlisting}[caption={Verify \textit{multi-fasta\_split.sh} script execution}]
# List newly established directories
|<$>| ls -d 4.* | more
4.multi-locus_seqs
4.rITS_seqs
4.rps_seqs
4.ycf1_seqs
\end{lstlisting}

\clearpage

\setcounter{lstlisting}{17}
\begin{lstlisting}[caption={Continued}]
# List the first three sequence string files split from the
# 3.unwrapped_fastas/multi-locus_unwrapped.fasta file.
$ ls 4.multi-locus_seqs/ | head -3
LARGY_7548.seq
LFEND_4355.seq
PACUT_14050.seq

# Verify sequence files have a line count equal to one.
$ wc -l 4.multi-locus_seqs/* | head -3
       1 4.multi-locus_seqs/LARGY_7548.seq
       1 4.multi-locus_seqs/LFEND_4355.seq
       1 4.multi-locus_seqs/PACUT_14050.seq
\end{lstlisting}

\vspace*{30pt}

\subsection*{9. FASTA File Split}

\paragraph{} In the FASTA-split loop construct above, the unwrapped aligned FASTA sequences for the concatenated multi-locus data set and each individual loci FASTA file in the \textit{3.unwrapped\_fastas/} directory are given as input files for the \textit{multi-fasta\_split.sh} shell script.  Within the script, the FASTA file is represented by the the input shell variable \textbf{\$1}.  This script initially stores the relative path from the working directory to the directory containing the input multi-FASTA file (i.e. \textbf{4.\$\{loci\}\_seqs/}).  

\paragraph{} Here, the variable construct \textbf{\$(dirname \$1)} uses command expansion of the \textbf{dirname}utility to return the directory path of the shell variable \textbf{\$1} representing the input file as the variable "fasta\_path".  The input file is then split every two lines using the \textbf{split} utility with the command flag â-l 2â.  This action creates new files named "seq.â in the \textbf{4.\$\{loci\}\_seqs/} directory, where each file has a unique extension appended (i.e. .aa, .ab, .ac, etc.).  Each split file then consists of two lines, including a sequence header and a corresponding sequence string.  The previously copied unwrapped FASTA file is then removed, leaving only the split single sequence FASTA files, and the working directory is changed to the \textbf{4.\$\{loci\}\_seqs} subdirectory represented by the variable \textbf{\$fasta\_path}.

\vspace*{30pt}

\begin{lstlisting}[caption={Contents of the \textit{multi-fasta\_split.sh} script}]
### multi-fasta_split.sh ###

# Save the path from the working directory to input file $1.
# Variable $fasta_path represents relative path to input FASTA file.
fasta_path=$(dirname $1)

# Within the directory containing the input file,
# split every two lines of the multi-FASTA file into separate files.
split -l 2 $1 $fasta_path/seq.

# Remove the unsplit multi-FASTA file and set working directory.
rm $1
cd $fasta_path
\end{lstlisting}

\vspace*{30pt}

\paragraph{} A loop is set up to iterate through the files created by \textbf{split} - each beginning with the substring "seq", in the working directory.  For each iteration of the loop, the variable "split\_seq" represents a split sequence file in the working directory.  The files iterated through in the for loop are indicated by the \textbf{\$(ls seq)} construct, which uses expansion of the \textbf{ls} utility to list all filenames beginning with âseqâ.  For each split sequence file, an AWK statement is used to store the sequence header as the variable "fasta\_header".  Offset variable expansion is then used to remove the ">" character, storing the sliced sequence header string in a new variable "fasta\_renamed".  The  \textbf{mv} utility is then used to rename the file by the sliced sequence header string in the variable "fasta\_renamed".  Finally, an AWK statement is used to redirect the record containing the sequence string into a new file named by \textbf{\$fasta\_renamed.seq}.  This script effectively renames each file in the working directory from âseq.\*â to the FASTA file sequence header and removes the sequence header, leaving only the alignment gapped sequence string.

\vspace*{30pt} 

\begin{lstlisting}[caption=\textit{multi-fasta\_split.sh} removal of sequence header]
# For each file, rename it with the first record (i.e. FASTA header)
for split_seq in $(ls seq*); do
  
  # Use command expansion to return the output of an AWK statement
  fasta_header=$(awk '/^>/ {print $0}' $split_seq);
  
  # Remove the ">" character from each file name using
  # offset variable substitution of first character.
  fasta_renamed=${fasta_header:1};  
  
  # Rename each file with the value of the files FASTA header record
  # echo $fasta_header $fasta_renamed;
  mv $split_seq $fasta_renamed
  
  # Remove FASTA sequence header by redirecting standard output 
  # of records not matching ">" at beginning of the line
  # into new file with ".fasta" file extension.
  awk '!/^>/ {print $0}' $fasta_renamed > $fasta_renamed.seq;
  
  # Remove FASTA file with the sequence header remaining.
  rm $fasta_renamed;
  
done
\end{lstlisting}

\clearpage

\subsection*{8. Source Sequences into R}

\paragraph{} An R function was written to load separated sequence strings into R as individual variables named by the original sequence header.  The R script \textit{load\_fastas.R} can be sourced into the global environment within R.  

\vspace*{30pt}

\begin{lstlisting}[caption=R session info]
|<$>| R

R version 3.4.4 (2018-03-15) -- "Someone to Lean On"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

> getwd()  # Get current working directory
[1] "/Physaria_spatial_analysis/Phys_DNA/Seq-Analysis"

> list.files() # Files in the current directory
 [1] "0.raw_fastas"       "1.trimmed_fastas"   "2.aligned_fastas"  
 [4] "3.unwrapped_fastas" "4.multi-locus_seqs" "4.rITS_seqs"       
 [7] "4.rps_seqs"         "4.ycf1_seqs"        "Fasta_Utilities"   
[10] "merge-notes.rtf"    "README.md"        

> source("Fasta_Utilities/R_functions/load_fastas.R")
> ls()  # Function is sourced into the workspace
[1] "load_fastas"
> class(load_fastas)
[1] "function"
\end{lstlisting}

\clearpage

\paragraph{} The \textit{load\_fastas} function takes two arguments, the first of which should be a path (provided as a character string) to the directory in which the split sequences are located. The second should be a string to establish which loci to pre-append to the sequence string variables that will result from calling this function.  When the function is called, a list of the files names is established as the variable \textbf{seq\_names} and a list of full paths to these files is stored in the variable \textbf{seq\_paths}.  A loop is then used to iterate over each split sequence file using the file path, and read the sequence string from the file into the local variable \textbf{seqRead}.  That variable is then assigned to the global environment based on the filename (i.e. the sequence header) and a prefixed loci name.

\vspace*{30pt}

\begin{lstlisting}[caption={Contents of the \textbf{load\_fastas} function}]
load_fastas <- function(directory, loci) {
    # Create a list of file names to be used for variable names
    seq_names <- as.list(list.files(directory))
    # Create a list of file paths to be used to read files
    seq_paths <- as.list(list.files(directory, full.names = TRUE))
    # Establish a loop index
    num_files <- length(seq_paths)
    # Loop through the directory and read sequences into
    # Variables named as the filename
    for(i in 1:num_files) {
        # Store the sequence string in a local variable
        seqRead <- readLines(seq_paths[[i]])
        # Assign the sequence string to the global environment
        # combining the loci name and the name from the sequence header
        assign(paste(as.character(loci), seq_names[[i]], sep = "_"),
               seqRead, envir = .GlobalEnv)
    }
}
\end{lstlisting}

\clearpage

\paragraph{} Calling this function on the \textit{4.multi-locus\_seqs*} subdirectory will load each of the individual sequence files as a variable containing a single sequence string.

\vspace*{30pt}

\begin{lstlisting}[caption=Source sequence data into R workspace]
# Run the function to import multi-locus (concatenated) sequences
> load_fastas("4.multi-locus_seqs/", "ml")

# Return the first 6 sequence vectors matching ".seq"
> head( ls( pattern = ".seq" ) )
[1] "ml_LARGY_7548.seq"  "ml_LFEND_4355.seq"  "ml_PACUT_14050.seq"
[4] "ml_PACUT_14222.seq" "ml_PACUT_26706.seq" "ml_PACUT_3721.seq" 

# The sequence strings are stored as character variables
> class(ml_LARGY_7548.seq)
[1] "character"

# Total string length is 2162 characters, with three loci partitions:
# rITS[1:659], rps[660:1605], ycf1[1606:2162]
> nchar(ml_LARGY_7548.fasta)
[1] 2162
\end{lstlisting}

\vspace*{30pt}

\paragraph{} Another R function, \textbf{seq\_comp} can then be used to identify indices for which pairwise alignments differ.  This function takes two arguments, âseq1â and âseq2â, each of which should be strings of identical length (i.e. aligned sequences).  An initial pairwise comparison is made between the two input sequences to check for sequence identity.  If the sequences are identical, the function returns a string to notify the user.  If the sequences are not identical, an index is created equal to the number of characters contained in each string.  An empty matrix with 2 rows and a column number equal to the sequence index is then created.  The function then loops through the length of the aligned sequences and fills the matrix with individual sequence characters from the input sequences.  This is accomplished using the function \textbf{substr} to return the character substring of the sequence corresponding to the index and store that character in the corresponding index of the matrix.  Finally, a comparison between the matrix rows (i.e. aligned sequences) returns which indices differ in the alignment.  

\vspace*{30pt}

\begin{lstlisting}[caption={Contents of the \textbf{seq\_comp} function}]
seq_comp <- function(seq1, seq2) {
    if(identical(seq1,seq2) == TRUE) {
        print("Sequences are identical.")
    } else {
        # Index vector == length of the (forward) sequence
        seq_index <- nchar(seq1)
        # Empty matrix for storing the substring
        # of sequence character vectors
        DNA_seq <- matrix(data = NA, nrow = 2, ncol = seq_index)
        # Loops through the length of f & r sequences
        # taking a substring for i in sequence length
        for(i in 1:seq_index) {
            DNA_seq[1,i] <- substr(seq1, i, i)
            DNA_seq[2,i] <- substr(seq2, i, i)
        }
        print(which(DNA_seq[1,] != DNA_seq[2,]))
    }
}
\end{lstlisting}

\clearpage

\paragraph{} The sequence comparison function returns those indices where pairwise comparisons are inequivalent.  This function was used to verify sequence identity as measured by the MEGA7 distance estimation.   

\vspace*{30pt}

\begin{lstlisting}[caption=Example of the \textbf{seq\_comp} function,
    basicstyle=\small]
# Source the seq_comp function
> source("Fasta_Utilities/R_functions/seq_comp.R")

# Compare multi-locus alignments of P. integrifolia and P. didymocarpa
> seq_comp(ml_PINTE_17493.seq, ml_PDIDY_DI_46.seq)
[1]  137  224  468  897 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480
[16] 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1605
\end{lstlisting}
