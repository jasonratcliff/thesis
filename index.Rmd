---
title: "Systematics of *Physaria* sensu stricto"
author: "Jason Ratcliff"
date: "`r Sys.Date()`"
maintfont: Palatino
fontsize: 12
output:
  bookdown::pdf_book:
    includes:
      in_header: TeX/Thesis_0-header.tex
    latex_engine: xelatex
    citation_package: natbib
    toc: false
    keep_tex: yes
subparagraph: true
site: bookdown::bookdown_site
documentclass: report
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "R Bookdown build to compile MS Thesis."
---

```{r knitrOptSet, message=FALSE, echo=FALSE, warning=FALSE}
# Set Global knitr chunk options
library(knitr)
knitr::opts_chunk$set(dev='pdf', echo=FALSE, results="asis",
                      message=FALSE, cache=FALSE)
opts_knit$set(eval.after = 'fig.cap')
```

\include{TeX/Thesis_1-copyright}

\include{TeX/Thesis_2-abstract-title}

\include{TeX/Thesis_3-abstract}

\include{TeX/Thesis_4-thesis-title}

\include{TeX/Thesis_5-approval}

\include{TeX/Thesis_6-tables}

```{r globalSet}
# Load libraries
require(dplyr)
require(purrr)
require(knitr)
require(magrittr)
require(lubridate)
require(stringr)
require(tibble)
require(kableExtra)
require(ggplot2)
require(lemon)
require(ggmap)
require(ggtree)
require(msa)
require(elevatr)
require(sp)

# Due to issue with ggmap call, developer branch of ggmap
# addressing issue from https://github.com/dkahle/ggmap/issues/85
# with fix at https://github.com/dkahle/ggmap/pull/88
# used for ggmap build.  See citation here:
# https://journal.r-project.org/archive/2013-1/kahle-wickham.pdf
if ("ggmap" %in% rownames(installed.packages()) == FALSE) {
  # Install from author github repo master branch
  library(devtools)
  devtools::install_github("dkahle/ggmap")
}

# # Load bioconductor packages 'ggtree' and 'msa'
# if ("ggtree" %in% rownames(installed.packages()) == FALSE) {
#   biocLite("ggtree")
# }
#
# if ("msa" %in% rownames(installed.packages()) == FALSE) {
#   biocLite("msa")
# }

# Read specimen data to Global Environment and source R functions.
source("R/specimen_data.R", keep.source = FALSE)
source("R/specimen_tools.R", keep.source = FALSE)
source("R/map_tools.R", keep.source = FALSE)
source("R/phylo_tools.R", keep.source = FALSE)
source("R/trait_tools.R", keep.source = FALSE)
source("R/knitr_helper.R", keep.source = FALSE)

# Assign global variable for type of knitr chunk (i.e. 'latex' | 'html').
knitr_chunk <- opts_knit$get("rmarkdown.pandoc.to")

# Define map object for state and county boundaries.
gg_borders <- map_borders(border_color = "black")

```

```{r sequencedHerbariumRecords}

# Read in sequenced DNA specimen information including accession labels.
dna_specimens <- readr::read_csv(file = "data/phylogeny/dna_specimens.csv") %>%
  dplyr::rename(label = taxa_label)

# Combine herbarium specimen record information with sequence documentation.
dna_herbarium_spp <-
  purrr::pmap_dfr(dna_specimens,
    function(label, Collector, Collection_Number, ...) {

      # Subset total herbarium record data frame by collector and collection.
      dna_herbarium <-
        total_physaria[intersect(
          stringr::str_which(string = total_physaria$Collector,
                             pattern = Collector),
          stringr::str_which(string = total_physaria$Collection_Number,
                             pattern = as.character(Collection_Number))), ] %>%
        dplyr::mutate(Collection_Number = as.numeric(Collection_Number))

      # Join the herbarium records to matching sequencing specimen .csv rows.
      specimen_label = label
      dplyr::left_join(dplyr::filter(dna_specimens, label == specimen_label),
                       dna_herbarium, by = "Collection_Number")
}) %>% # Clean up a few columns and reorder for easy review.
  dplyr::select(label, Collection_Number, Collector.x, Collector.y,
                dplyr::contains("Physaria"), dplyr::contains("Taxon"),
                dplyr::contains("ID_"), Herbarium.x, Herbarium.y,
                State.x, State.y, County.x, County.y,
                Date, Date_parsed, Date_md,
                ID, App.A, `Elev_(m)`, `Elev_(ft.)`,
                Latitude.x, Latitude.y, Longitude.x, Longitude.y,
                Imaged, TRS2, Notes, Rosulate, Caudex, Pubescence,
                Basal_leaf_trichomes, Fruit_trichomes, Stem_count,
                Stem_shape, Stem_length_dm, Petiole, Basal_leaf_length_cm,
                Basal_leaf_shape, Basal_leaf_margins, Cauline_leaf_length_mm,
                Cauline_leaf_shape, Cauline_leaf_margins, Racemes,
                Pedicel_shape, Pedicels_secund, Sepal_length_mm, Sepal_shape,
                Petal_color, Petal_length_mm, Petal_shape, Style_length_mm,
                Mature_fruit_length_mm, Mature_fruit_width_mm, Fruit,
                Mature_fruit_apices, Replum_pubescence, Inner_valve_pubescence,
                Ovule_number, Replum_shape, Seed_color, Seed_shape,
                Mature_seed_length_mm) %>%
  dplyr::rename(Latitude = Latitude.x, Longitude = Longitude.x)

# Write merged specimen data to file.
readr::write_excel_csv(dna_herbarium_spp,
                       path = "data/beast/dna_herbarium_spp.csv")

```

```{r sequencedMaps, eval=FALSE}

# Function wrapper to map sequenced DNA specimens with accession labels.
map_sequenced <- function(dna_herbarium_spp_subs, aes_point,
                          label_subset = "", x_nudge = 0, y_nudge = 0.275,
                          f_adjt = 0.2) {
  map_specimens(map_df = dna_herbarium_spp_subs, map_col = aes_point,
                f_adj = f_adjt) +
    geom_label2(data = dplyr::rename(dna_herbarium_spp_subs, taxa_label = label),
                mapping = aes(x = Longitude, y = Latitude, label = taxa_label,
                              subset = !(taxa_label %in% label_subset)),
                inherit.aes = FALSE, na.rm = TRUE, label.size = 0.1,
                alpha = 0.5, nudge_x = x_nudge, nudge_y = y_nudge) +
    theme(legend.position = "bottom", legend.direction = "vertical") +
    guides(col = guide_legend(ncol = 2))
}

# Check for merged data frame used in `map_sequenced.R` script and build maps.
if (exists(x = "dna_herbarium_spp", where = .GlobalEnv)) {
  source("R/map_sequenced.R")
}

```

```{r chapter1Set}

# Subset Carbon County, Wyoming specimens within bounding box.
spp_carbon_wyo <- spp_subset(taxa_frame = total_physaria,
                             state = c("Wyoming", "Colorado"),
                             longitude = c(-107.9, -105.1),
                             latitude = c(39.1, 41.9))

```
